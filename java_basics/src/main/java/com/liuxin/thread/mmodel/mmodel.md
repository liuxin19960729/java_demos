## 并发编程的两个关键性问题
```
线程之间通信和同步

java 共享内存模型(通信,对共享内存进行修改等操作)


JMM java内存模型--线程之间通信

Threa main Memeory  共享内存

Local Memory(JMM的一个抽象概念实际上并不存在) 每一个线程都有一个私有本地内存 存储了该线程读写内存变量的副本


```

### 从源码到指令重排序
```
为了么重排序

编译器 重排序 和 CPU重排序对提高性能


编译器重排序:不改变单线程程序的语意前提下可以重新安排语句的执行顺序

指令并行的重排序:多条指令如果不存在数据依赖可以多条语句重叠执行

内存重排序:处理器使用缓存的读和写,使得加载和操作看上去可能在执行乱序操作。(cpu每次到内存获取数据都是一个cacheLine)
   在不出错的情况下,优先操作同一缓存行的操作。



写缓冲区->保证指令流水线持续运行(避免写入数据到内存处理器停顿下来)-->缓冲区使用批量的方式刷新


                                                                                                                                                                                                                                                               
```

### 处理器重排序规则
```
StoreLoad Barrier  store1:StoreLoade store2
    store1前面的所有内存访问执行完才会执行store2的内存访问指令

StoreLoad Barrier 执行昂贵,会把缓冲区的数据全部刷新到内存中
                                 
```

### happens-before 介绍
```
保证线程之间可见线程之间必须存在happens-before 关系


sycgronized(){
A   
}
B

B 之前的操作Adui对任意线程可见


A
valatile
C
valatile 之前的操作对任意线程可见
```

## 重排序
```
写后读
    a=1
    b=a

写后写
    a=1
    a=2

读后写
   a=b
   b=1

上面三种情况只要进行重排序数据就会改变


在单线程中编译器和处理器在不改变结果的情况下(单线程) 会进行重排序


例：
 double a=1;//A
 double b=3;//B
 double c=a*b;//C

C 依赖AB  C不能重排序 
AB之间没有数据依赖可以进行重排序


note:JMM 并不要求A happen-brfore B
      jMM要求AB 对C操作时可见的

```
### 数据竞争与顺序一致性
```
一个程序写一个变量
一个程序同时读一个变量


在任意时刻只有一个线程对内存进行读写
在并发时刻,可以看成对内存操作时串行化的


```

### 总线事物
```
一个线程的获得总线事物的操作会进制其他CPU的IO操作

当多个处理器并发发起多个总线事务,这时总线会管理者会对事物做出一个裁决，让谁先执行

当有处理器在执行总线事物期间任意CPU发起的中线事务都会被总线进制


JDK5之前 long double 读和写都被拆分为2个32位的读写
JDk5>= 之后 long 读具有原子性(必须在单个事物进行读)，写还是才分两个32位来写

```

## volatile的内存语义
```
单个读写操作具有原子性

Ax线程写之前的所有变量对其他线程可见


```
### volatile 限制的重排序
```
1
 1.1
 1.2 volatile 写
确保valatile写会将前面的数据全部写入内存  --- happen-before 必须保证前面的数据写入到内存

2
  2.1:valatile 读
  2.2 后面的任何操作不允许排到valatile前面
3
   2.1 valatile 写
   2.2 valatile 读 不能进行重排序
    
```

## final
```
final 变量在构造函数里面赋值初始化不允许重排序

禁止把final的写排序重写到构造器之外,编译器会把final 写之后 构造函数返回(return)之前 插入一条StoreStore的屏障 


初次读对象和初次读对象的final 这两个操作不允许重排序

final Obj obj
construc(){
  obj=new Obj()
  obj.a=100; //1
}

getObg();//1 1和 2 不允许重排序


Obj obj=AA.getObj()
sout(obj.a) // 2  1-2不允许重排序



```