

## volatile
```
不加volatile字段:
会写入到L1,L2,不会直接写入内存,在某一时刻才会写入内存
  

和volatile 修饰无关，只要数据写入到内存就会保证数据的一致性

  没个处理器通过嗅探总线上传播的数据来检查自己的数据是否过期,检查到在自己自己数据过期设置为invalid,
  当要使用数据的时候到内存重新更新到缓冲行


会被JIt编译器编译为:lock xxx  xxx
1.lock 前缀指令,更新缓存,直接把数据同步到内存
  以前cpu:
     独占内存
  现代CPU
     两种情况
     1.对应地址的缓冲行已经在CPU内部,不会发送lock指令的广播
     2.在内存,没有在缓冲行,发送lock广播锁住内存对应区域的cacheLine,把数据写到内存,缓存一致性机制会组织两个以上的
CPU来修改数据

  
2.其他CPU接收到该信号做出一些对应的操作


3.缓存数据写入到内存,会导致其他CPU对应该地址缓存失效
      IA-32 和Intel64 MESI(修改,独占,共享 无效)保证数据一致性    
      IA-32 和Intel64对应的多核CPU中他们是能够嗅探到其他CPU访问共享内存和他们内部的缓存的操作


MESI
              CPU0      CPU1   Memory
CPU0 read(x)   x=1 (E)           x=1
CPU1 read(x)   X=1(Share) x=1(Share) x=1   
CPO  write(x,9) x=9(M)   x=1(invalid) x=1
x 写回内存       X=9(M)  x=1  x=9 
CPU1 read()   x=9(S)  x=9(S) 同步到cache中 状态变成Shared



CPU 锁缓冲的最小单位是锁住整个缓冲行



```

## syncronized
```
syncronized(){
    
}

是基于Moniter来实现
这两个指令
moniterenter
moniterexit 方法结束和异常出会自动插入

任何对象都有一个Moniter

markWord
无锁
  01 00 00 00 (00000001 00000000 00000000 00000000) (1)
     2bits 01 偏向锁or 无锁
     1bits 0 无锁 


markWord
加锁
78 c9 48 0a (01111000 11001001 01001000 00001010) (172542328)
01111000 
00 轻量级锁
指向栈中锁记录的指针
(小端)
  00001010  01001000 11001001 


10 重量级锁 
(01011010 10110101 00000001 01000110) (1174517082)
 小端
 01000110  00000001 10110101  11010

表示GC标记
 11

偏向锁  
 [23bits=线程ID]  ..........1  01 


无锁->偏向锁->轻量级锁->重量级锁
锁只能升级不能降级

```
### 偏向锁
```
为什么要有偏向锁?
    在大多数情况下,锁不仅不存在竞争,而且会由同一个线程多次获得锁

执行流程
入锁执行流程
1.check 是否是当前线程
   否 偏向锁的标志是否1(000 无锁  100偏向锁)
      否:不是偏向锁,CAS竞争(无锁,轻量级锁,重量级锁)
      是:是偏向锁,使用CAS将markWork 头执行当前线程
   是:进入锁

偏向锁撤销
当存在其他线程竞争时偏向锁才会释放锁(释放时机:在这个时间点上没有正在执行的字节码)
 释放步骤:
     (lock object markWord 记录的有线程ID)
   1.暂停拥有偏向锁线程(不让他有可能Interrupy等的可能),检查持有偏向锁的线程是否还活着,
       否(不存在该线程):设置成无锁
       是(活着 wait wait(timeout)):
          拥有偏向锁的栈(markWork记录的线程号对应的那个栈),遍历Lock object的锁记录,
             1.偏向其他线程
             2.设计成无锁or 标记为不适合作为偏向锁
   
```
## 轻量级锁
```
轻量级获得锁
在执行同步块时，
1.在栈中矿建一个存储锁记录的区域
2.并将锁对象的MarkWord复制到记录中
3.CAS将对栈中对象有指针指向锁记录
4.成功获得锁,失败表示其他线程竞争锁,(当前表示通过自旋转来获得锁)

轻量级解锁
CAS将Displaced  MarkWord 替到对象头里面 
成功没有竞争 
失败 表示当亲存在竞争,升级为重量级锁

释放时升级为重量级锁,当前其他线程试图获取锁，会被阻塞住,当，当前线程被释放时,唤醒阻塞的线程，进行下一轮的争抢

```

##原子操作的实现原理
```
IA-32 使用基于对缓存加锁(内存里面对应的CacheLine,不是L1,L2,L3)和总线加锁的方式实现多处理器之间的原子操作

1.总线保证原子性
  Cpu1 i
  Cpu2 i
   i是共享内存Cpu总线锁当CPU1 对i 进行操作时 其他线程i是不能进行操作的


lock 信号

lock信号被广播出去的时候，其他CPU的请求将独占内存

2.缓存锁在同一时刻保证对某个内存cacheLine的操作被锁住(比总线锁更加高效)
  
    缓存锁定
        当执行锁定操作的时候,发现数据被缓存在处理器缓存中，就选择使用缓存锁。使用Cpu内部缓存一致性来保证
        原子性(MESI协议)
        
         [cpu1 [cacheline1 modified]]     [cpu1 [cacheline1 invaild]] 无效Cpu2不能对该缓存行的数据进行操作


存在不使用缓存锁的情况

1.数据不存在处理器内部(L1,L2,L3),跨越多个缓存行(缓存行只能保证一个缓存行锁定)操作处理器会使用总线锁定

2.还有些CPU不支持缓存行的操作



```




















