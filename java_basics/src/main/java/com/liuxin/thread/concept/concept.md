

## volatile
```
不加volatile字段:
会写入到L1,L2,不会直接写入内存,在某一时刻才会写入内存
  

和volatile 修饰无关，只要数据写入到内存就会保证数据的一致性

  没个处理器通过嗅探总线上传播的数据来检查自己的数据是否过期,检查到在自己自己数据过期设置为invalid,
  当要使用数据的时候到内存重新更新到缓冲行


会被JIt编译器编译为:lock xxx  xxx
1.lock 前缀指令,更新缓存,直接把数据同步到内存
  以前cpu:
     独占内存
  现代CPU
     两种情况
     1.对应地址的缓冲行已经在CPU内部,不会发送lock指令的广播
     2.在内存,没有在缓冲行,发送lock广播锁住内存对应区域的cacheLine,把数据写到内存,缓存一致性机制会组织两个以上的
CPU来修改数据

  
2.其他CPU接收到该信号做出一些对应的操作


3.缓存数据写入到内存,会导致其他CPU对应该地址缓存失效
      IA-32 和Intel64 MESI(修改,独占,共享 无效)保证数据一致性    
      IA-32 和Intel64对应的多核CPU中他们是能够嗅探到其他CPU访问共享内存和他们内部的缓存的操作


MESI
              CPU0      CPU1   Memory
CPU0 read(x)   x=1 (E)           x=1
CPU1 read(x)   X=1(Share) x=1(Share) x=1   
CPO  write(x,9) x=9(M)   x=1(invalid) x=1
x 写回内存       X=9(M)  x=1  x=9 
CPU1 read()   x=9(S)  x=9(S) 同步到cache中 状态变成Shared



CPU 锁缓冲的最小单位是锁住整个缓冲行



```

## syncronized
```
syncronized(){
    
}

是基于Moniter来实现
这两个指令
moniterenter
moniterexit 方法结束和异常出会自动插入

任何对象都有一个Moniter

markWord
无锁
  01 00 00 00 (00000001 00000000 00000000 00000000) (1)
     2bits 01 偏向锁or 无锁
     1bits 0 无锁 


markWord
加锁
78 c9 48 0a (01111000 11001001 01001000 00001010) (172542328)
01111000 
00 轻量级锁
指向栈中锁记录的指针
(小端)
  00001010  01001000 11001001 


10 重量级锁 
(01011010 10110101 00000001 01000110) (1174517082)
 小端
 01000110  00000001 10110101  11010

表示GC标记
 11

偏向锁  
 [23bits=线程ID]  ..........1  01 


无锁->偏向锁->轻量级锁->重量级锁
锁只能升级不能降级

```
### 偏向锁
```
为什么要有偏向锁?
    在大多数情况下,锁不仅不存在竞争,而且会由同一个线程多次获得锁

执行流程
入锁执行流程
1.check 是否是当前线程
   否 偏向锁的标志是否1(000 无锁  100偏向锁)
      否:不是偏向锁,CAS竞争(无锁,轻量级锁,重量级锁)
      是:是偏向锁,使用CAS将markWork 头执行当前线程
   是:进入锁

偏向锁撤销
当存在其他线程竞争时偏向锁才会释放锁(释放时机:在这个时间点上没有正在执行的字节码)
 释放步骤:
     (lock object markWord 记录的有线程ID)
   1.暂停拥有偏向锁线程(不让他有可能Interrupy等的可能),检查持有偏向锁的线程是否还活着,
       否(不存在该线程):设置成无锁
       是(活着 wait wait(timeout)):
          拥有偏向锁的栈(markWork记录的线程号对应的那个栈),遍历Lock object的锁记录,
             1.偏向其他线程
             2.设计成无锁or 标记为不适合作为偏向锁
   
```
## 轻量级锁
```
在执行同步块时，
1.在栈中矿建一个存储锁记录的区域
并将锁对象的MarkWord复制到记录中

```




















